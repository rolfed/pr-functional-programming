<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Functional Programming by Danniel Rolfe</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/moon.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">


	<style>
		.attention {
			font-weight: bold;
			font-style: italic;
		}
		.attention-underscore {
			text-decoration: underline;
		}
		.attention-white {
			color: white;
		}
		.attention-orange {
			color: #F25C05;
		}
		.attention-pink {
		  color: #D9043D;
		}
	</style>
</head>
<body>
<div class="reveal">
	<div class="slides">
		<!-- SLIDE 1 -->
		<section data-transition="slide" data-background-color="rgba(224,255,105, 1)">
			<h2>Functional Programming 1/2:</h2>
			<h2>Simplifying Code Complexity</h2>
			<p>Papoy Team - Danniel Rolfe</p>
			<br>
			<a href="https://rolfed.github.io/pr-functional-programming">https://rolfed.github.io/pr-functional-programming/</a>
		</section>

		<!-- SLIDE 2 -->
		<section data-transition="slide" data-background-color="rgba(224,255,105, 1)">
			<section>
				<h2>The Scope of This Presentation</h2>
			</section>
			<section data-transition="fade-in fade-out">
				<p class="fade-in slide-out">This presentation is an overview of key concepts in functional programming,
					aimed at introducing software engineers to this paradigm</p>
			</section>
			<section data-transition="fade-in fade-out">
				<p class="fade-in slide-out">This presentation is not a deep dive into advanced topics in functional
					programming, but rather a broad introduction to its benefits and principles</p>
			</section>
			<section data-transition="fade-in fade-out">
				<p class="fade-in slide-out">This presentation is intended for developers who are new to functional
					programming or who are interested in learning more about this approach to software development</p>
			</section>
			<section data-transition="fade-in fade-out">
				<p class="fade-in slide-out">This presentation is not a language-specific tutorial on how to use functional
					programming in a particular programming language, but rather a general overview of its principles and techniques</p>
			</section>
			<section data-transition="fade-in fade-out">
				<p class="fade-in slide-out">By the end of this presentation, you will have a basic understanding
					of the principles of functional programming and how they can be applied to improve code quality
					and maintainability</p>
			</section>
		</section>

		<!-- SLIDE 3 -->
		<section data-transition="slide" data-background-color="rgba(224,255,105, 1)">
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
			</section>
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
				<ol>
					<li>Concepts of functional thinking</li>
				</ol>
			</section>
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
				<ol>
					<li>Concepts of functional thinking</li>
					<li>Functions as first-class citizens</li>
				</ol>
			</section>
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
				<ol>
					<li>Concepts of functional thinking</li>
					<li>Functions as first-class citizens</li>
					<li>Higher-order functions</li>
				</ol>
			</section>
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
				<ol>
					<li>Concepts of functional thinking</li>
					<li>Functions as first-class citizens</li>
					<li>Higher-order functions</li>
					<li>Immutable data structures</li>
				</ol>
			</section>
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
				<ol>
					<li>Concepts of functional thinking</li>
					<li>Functions as first-class citizens</li>
					<li>Higher-order functions</li>
					<li>Immutable data structures</li>
					<li>Functional design patterns</li>
				</ol>
			</section>
			<section data-auto-animate>
				<h2>Topics that we will <br>cover in this presentation:</h2>
				<ol>
					<li>Concepts of functional thinking</li>
					<li>Functions as first-class citizens</li>
					<li>Higher-order functions</li>
					<li>Immutable data structures</li>
					<li>Functional design patterns</li>
					<li>Q&A</li>
				</ol>
			</section>
		</section>

		<!-- SLIDE 4 -->
		<!-- Concepts of functional thinking -->
		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h1>What is Functional Programming?</h1>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<h2>Academic definition</h2>
			</section>
			<section data-auto-animate>
				<h2>Academic definition</h2>
				<div style="text-align: left">
					<p>A programming paradigm characterized by the use of mathematical functions and the avoidance of side effects</p>
					<p style="font-size: 14px; font-weight: bold;">&#8212; Side effects are any behaviour of a function besides the return value</p>
				</div>
			</section>
			<section data-auto-animate>
				<h2>Academic definition</h2>
				<div style="text-align: left">
					<p>A programming paradigm characterized by the use of mathematical functions and the avoidance of side effects</p>
					<p style="font-size: 14px; font-weight: bold;">&#8212; Side effects are any behaviour of a function besides the return value</p>
					<p>A programming style that uses only pure functions without side effects</p>
					<p style="font-size: 14px; font-weight: bold;">&#8212; Pure functions depend only on their arguments and don't have any side effects</p>
				</div>
			</section>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Wait, Don't our applications depend on side effects?</h2>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<h2>Side effects we work with every day:</h2>
			</section>
			<section data-auto-animate>
				<h2>Side effects we work with every day:</h2>
			    <p>Writing to a database</p>
			</section>
			<section data-auto-animate>
				<h2>Side effects we work with every day:</h2>
				<p>Writing to a database</p>
				<p>Sending HTTP requests</p>
			</section>
			<section data-auto-animate>
				<h2>Side effects we work with every day:</h2>
				<p>Writing to a database</p>
				<p>Sending HTTP requests</p>
				<p>Updating UI</p>
			</section>
			<section data-auto-animate>
				<h2>Side effects we work with every day:</h2>
				<p>Writing to a database</p>
				<p>Sending HTTP requests</p>
				<p>Updating UI</p>
				<p>Logging to Splunk</p>
			</section>
			<section data-auto-animate>
				<h2>Side effects we work with every day:</h2>
				<p>Writing to a database</p>
				<p>Sending HTTP requests</p>
				<p>Updating UI</p>
				<p>Logging to Splunk</p>
			</section>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<p>
				Functional programmers are experts at organizing functions in a way that makes code easier to work with.
			</p>
			<p>
				They're experts at minimizing the negative impact of side effects, which happen when a function does
				something beyond just giving an output.
			</p>
		</section>
		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<p>
				Side effects can be tricky to deal with because they can change
				variables or write to files. But functional programmers use special techniques to make sure everything
				works smoothly and that the code is easy to take care of over time. Overall, functional programmers
				masterfully structure functions with side effects to keep the code robust and maintainable.
			</p>
		</section>
		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>I prefer to think: </h2>
			<p>Functional programming is like building with blocks: <br>you use functions to solve problems in a way that
				makes it hard to make mistakes.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<h2>Examples of building blocks:</h2>
			</section>
			<section data-auto-animate>
				<h2>Examples of building blocks:</h2>
				<p>Actions<p>
			</section>
			<section data-auto-animate>
				<h2>Examples of building blocks:</h2>
				<p>Actions<p>
				<p>Calculations</p>
			</section>
			<section data-auto-animate>
				<h2>Examples of building blocks:</h2>
				<p>Actions<p>
				<p>Calculations</p>
				<p>Data</p>
			</section>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Actions: </h2>
			<p class="attention attention-white">
				Are depend on when they are called,
				<br>also known as side effects.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<h2>Actions:</h2>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="2|3|4|5-8">
					async function register() {
						const form = document.getElementById("form");
						const submitter = document.getElementById("submitter");
						const formData = new FormData(form, submitter);
						const res = await fetch(url, {
						  method: 'POST',
						  body: JSON.stringify(formData)
						});

						const res = await res.json();
						return res.json();
					}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<h2>Actions:</h2>
				<pre data-id="actions-code-animation">
					<code data-trim
					      data-line-numbers="2-9">
					async function register() {
						/** Side effects **/
						const form = document.getElementById("form");
						const submitter = document.getElementById("submitter");
						const formData = new FormData(form, submitter);
						const res = await fetch(url, {
						  method: 'POST',
						  body: JSON.stringify(formData)
						});

						return res.json();
					}
					</code>
				</pre>
			</section>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Calculations:</h2>
			<p class="attention-white">
				Are computations that only depend on inputs and outputs,
				also known as pure functions or mathematical functions.
			</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Calculations</h2>
			<pre data-id="actions-code-animation">
					<code data-trim data-line-numbers>
					function add(x, y) {
						return x + y;
					}
					</code>
				</pre>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Benefits of Calculations:</h2>
			<p class="attention-white">
				Are are easier to test.
			</p>
			<p class="attention-white">
				Machines have easier time analyzing the code.
			</p>
			<p class="attention-white">
				Calculations are composable.
			</p>

		</section>


		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Data:</h2>
			<p class="attention attention-white">
				Are records of facts about events.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Data</h2>
			<pre data-id="actions-code-animation">
					<code data-trim data-line-numbers>
						const emailList = [
						 { email: 'john@email.com', isCustomer: true },
						 { email: 'jim@email.com', isCustomer: false }
						]
					</code>
				</pre>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Benefits of Data:</h2>
			<p class="attention attention-white">
				Data is inert and transparent
			</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<p class="attention attention-white">
				Functional programmers typically begin by focusing on the data, perform calculations using it,
				and strive to minimize any side effects in their functions.
			</p>
		</section>


		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<h2>Let's apply functional thinking.</h2>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<p>Take a look at this code snippet:</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="1-4|5|7-11|13-16">
						var cart = [
						 { item: 'orange', quantity: 1, price: '0.99'},
						 { item: 'apple', quantity: 1, price: '0.97'},
						];
						var total = 0;

						function calcTotal() {
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						}

						function updateTotal() {
						  calcTotal();
						  console.log(`Total cost: $${total.toFixed(2)}`);
						}

					</code>
				</pre>
			</section>

			<section data-auto-animate>
				<p>Can you identify the actions, calculations or data?</p>
				<q class="attention-white">Ask yourself, does the function depend on when or how many times it runs?</q>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers>
						var cart = [
						 { item: 'orange', quantity: 1, price: '0.99'},
						 { item: 'apple', quantity: 1, price: '0.97'},
						];
						var total = 0;

						function calcTotal() {
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						}

						function updateTotal() {
						  calcTotal();
						  console.log(`Total cost: $${total.toFixed(2)}`);
						}

					</code>
				</pre>
			</section>

			<section data-auto-animate>
				<p>Can you identify the actions, calculations or data?</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="1-5|6-7|9-14|16-20">
						// Data
						var cart = [
						 { item: 'orange', quantity: 1, price: '0.99'},
						 { item: 'apple', quantity: 1, price: '0.97'},
						];
						// Data
						var total = 0;

						// Action
						function calcTotal() {
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						}

						// Action
						function updateTotal() {
						  calcTotal();
						  console.log(`Total cost: $${total.toFixed(2)}`);
						}
					</code>
				</pre>
			</section>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<p>In our presentation, we highlighted how <span class="attention attention-underscore">skilled Functional Programmers</span>
				adeptly <span class="attention attention-underscore">organize functions</span>
				with <span class="attention attention-underscore">minimal side effects</span>
				to reduce any adverse impact.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<p>Let's refactor our cart to minimize side effects</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers>
						function calcTotal() {
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						}

						function updateTotal() {
						  calcTotal();
						  console.log(`Total cost: $${total.toFixed(2)}`);
						}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<p>We need to update the calcTotal function to accept the cart
					as a parameter rather than accessing it directly.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="1-2">
						function calcTotal(cart) {
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<p>Next let's return the total to remove the dependency on the total global variable</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="2,6">
						function calcTotal(cart) {
						 var total = 0;
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						  return total.toFixed(2);
						}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<p>Next let's modify updateTotal() to accept our changes</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="10">
						function calcTotal(cart) {
						 var total = 0;
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						  return total.toFixed(2);
						}

						function updateTotal() {
						  const total = calcTotal(cart);
						  console.log(`Total cost: $${total}`);
						}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<p>What did we gain by this refactor?</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers>
						function calcTotal(cart) {
						 var total = 0;
						  for (let item of cart) {
					        total += item.quantity * parseFloat(item.price);
						  }
						  return total.toFixed(2);
						}

						function updateTotal() {
						  const total = calcTotal(cart);
						  console.log(`Total cost: $${total}`);
						}
					</code>
				</pre>
			</section>

			<section data-auto-animate>
				<p>By refactoring calcTotal() to be a calculation that accepts the cart as a parameter, you make it decoupled and modular in a couple of ways:</p>
			</section>
			<section data-auto-animate>
				<p>1. <span class="attention attention-underscore">Decoupling</span>: Previously, calcTotal() relied on a direct reference to the cart array, which can make it tightly coupled to other parts of your code. This can lead to issues if the cart array structure changes, as it can break the functionality of calcTotal(). By passing the cart as a parameter, calcTotal() becomes independent of the cart implementation and can work with any cart object that has the same structure</p>
			</section>

			<section data-auto-animate>
				<p>2. <span class="attention attention-underscore">Modularity</span>: By separating the calcTotal() function from the cart data, you increase the modularity of your code. This means that if you need to reuse the calcTotal() function in another part of your codebase, you can simply pass in a different cart object and it will work as expected. This makes your code more modular and easier to maintain, as changes to one part of the code won't impact other parts that depend on it</p>
			</section>
			<section data-auto-animate>
				<p>By refactoring calcTotal() to be a calculation that accepts the cart as a parameter, you make it more decoupled and modular. This leads to more robust and maintainable code.</p>
			</section>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<p>Imagine that the business makes a request that we offer free shipping to all orders that is greater
				than $20.00.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<p>Let's modify our code to implement this feature.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(247,133,48, 1)">
			<section data-auto-animate>
				<p>Add isFreeShipping() function.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="1|2-3|4-5|7">
						function isFreeShipping(cart) {
							 var freeShippingThreshold = 20;
							 var total = 0;
							 for (let item of cart) {
								total += item.quantity * parseFloat(item.price);
							 }
							return total <= freeShippingThreshold;
						}

					</code>
				</pre>
			</section>

			<section data-auto-animate>
				<p>Add isFreeShipping() function.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="18|19|20|21">
						function isFreeShipping(cart) {
							 var freeShippingThreshold = 20;
							 var total = 0;
							 for (let item of cart) {
								total += item.quantity * parseFloat(item.price);
							 }
							return total <= freeShippingThreshold;
						}

						function calcTotal(cart) {
							var total = 0;
							for (let item of cart) {
							  total += item.quantity * parseFloat(item.price);
							}
							return total.toFixed(2);
						}

						function updateTotal() {
						  const shippingCost = isFreeShipping(cart) ? 0 : 5;
						  const total = calcTotal(cart) + shippingCost;
						  console.log(`Total cost: $${total}`);
						}
					</code>
				</pre>
			</section>

		</section>

			<!-- HIGHER ORDER FUNCTIONS --->
		<section data-transition="slide" data-background-color="rgba(80,85,191, 1)">
				<p class="attention-white">Programming often involves repetitive actions and calculations on data,
					which can become cumbersome as programs become more complex.</p>
		</section>

		<section data-transition="slide" data-background-color="rgba(80,85,191, 1)">
			<h2>Higher Order Function</h2>
			<p class="attention-white">Higher order functions are useful in programming when we have repetitive actions and calculations to
				perform on data. They can simplify our code and make it more reusable, which is especially important
				as programs become more complex.</p>
		</section>
		<section data-transition="slide" data-background-color="rgba(80,85,191, 1)">
			<section data-auto-animate>
				<p class="attention-white">Remember the registration function we talked about at the beginning of
					this presentation? Let's take another look at it. As you can see, the function is doing two
					things.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers>
					async function register() {
						const form = document.getElementById("form");
						const submitter = document.getElementById("submitter");
						const formData = new FormData(form, submitter);
						const res = await fetch(url, {
						  method: 'POST',
						  body: JSON.stringify(formData)
						});

						return res.json();
					}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<p class="attention-white">Remember the registration function we talked about at the beginning of
					this presentation? Let's take another look at it. As you can see, the function is doing two
					things.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="2-4">
					async function register() {
						const form = document.getElementById("form");
						const submitter = document.getElementById("submitter");
						const formData = new FormData(form, submitter);
						const res = await fetch(url, {
						  method: 'POST',
						  body: JSON.stringify(formData)
						});

						return res.json();
					}
					</code>
				</pre>
			</section>
			<section data-auto-animate>
				<p class="attention-white">Remember the registration function we talked about at the beginning of
					this presentation? Let's take another look at it. As you can see, the function is doing two
					things.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers="5-10">
					async function register() {
						const form = document.getElementById("form");
						const submitter = document.getElementById("submitter");
						const formData = new FormData(form, submitter);
						const res = await fetch(url, {
						  method: 'POST',
						  body: JSON.stringify(formData)
						});

						return res.json();
					}
					</code>
				</pre>
			</section>
		</section>
		<section data-transition="slide" data-background-color="rgba(80,85,191, 1)">
			<p class="attention-white">Let's optimize register() by refactoring it and exploring how higher order functions can improve it.</p>
		</section>
		<section data-transition="slide" data-background-color="rgba(80,85,191, 1)">
			<section data-auto-animate>
				<p class="attention-white">Let's begin by abstracting the function that retrieves the form data.</p>
				<pre data-id="actions-code-animation">
					<code data-trim
						  data-line-numbers>
						function getFormData() {
							const form = document.getElementById('form');
							const submitter = document.getElementById('submitter');
							return new FormData(form, submitter);
						}
					</code>
				</pre>
			</section>
		</section>


	</div>
</div>

		<!-- SLIDE 4 -->


<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,
		slideNumber: 'c/t',
		showSlideNumber: 'print',
		navigationMode: 'linear',
		embedded: false,

		dependencies: [
			{
				src: 'plubin/reveal-run-in-terminal.js',
				callbackk: function() { RunInTerminal.init(); },
				async: true
			}
		],
		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [
			RevealMarkdown,
			RevealHighlight,
			RevealNotes,
		]
	});
</script>
</body>
</html>
